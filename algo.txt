//ALGORITHM:

global_sort(array, numthreads, threadid){
    if(numthreads == 1){
        return
    }
    locid = threadid % numthreads
    group = threadid / numthreads
    select a pivot accross entire array
    divide threads into first numthreads/2 threads and second numthreads/2 threads
    track both set of threads
    threadid of first set will exchange with (threadid + numthreads/2) of second thread 
    such that
        first numthreads/2 threads will have elements < pivot 
        second numthreads/2 threads will have >  pivot
    now each thread will have two piecewise sorted subarrays
    each thread will parallel-y merge those subarrays
    parallely execute {
        global_sort of (array, numthreads / 2)
    }
}

local_sort(array){
    perform normal quicksort maybe
}

MAIN:
for (t = 0, t < numthreads, t ++){
    allocate start and end for each threaddata[t]
    pthread_create(thread[t], NULL, local_sort, threaddata[t])
}
for (t = 0, t < numthreads, t ++){
    pthread_join(thread[t], NULL)
}

using the same above threads, do global_sort(whole of the array, numthreads)
//here u need to manage the thread variables in such a way that in first recursive step, all the numthreads are used
next step also all numthreads are used but paralelly for left half and right half
then next step, it is parallely used for first quarter,2nd quarter,3rd quarter,4th quarter
etc